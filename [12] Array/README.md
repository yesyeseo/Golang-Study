# Chapter 12. Array

## 12.1 배열

같은 타입의 데이터들로 이루어진 타입   

- 인덱스(index): 위치값, 0부터 시작
- 요소(element): 각 데이터

### 선언 방법

타입 앞에 크기를 붙여서 선언한다. → **var 이름 [크기]타입**     

ex. `var temps [5]float64`

## 12.2 배열 사용법

### 📌 배열 변수 선언 및 초기화

방법 1. 초깃값 지정 X      

→ int의 기본값 0으로 모두 초기화됨 `{0,0,0,0,0}`

```go
var nums [5]int  
```

방법 2. 선언대입문 `:=` 사용하여 바로 초기화

```go
days := [3]string{"monday", "tuesday", "sunday"}
```

방법 3. 일부만 초기화    

→ temps[0], temps[1]만 각각 24.3과 26.7로 초기화되고, 나머지는 float64의 기본값 0.0 으로 초기화됨

```go
var temps [5]float64 = [5]float64{24.3, 26.7}
```

방법 4. 인덱스 지정해주어 초기화   

→ s[1]=10 이고, s[3]=30 이 됨. 나머지는 int타입의 기본값 0으로 초기화.

```go
var s = [5]int{1:10, 3:30}
```

방법 5. `...`을 사용해 배열 요소 개수 생략    

```go
x := [...]int{10, 20, 30}
```

### 💡 주의. 배열 크기는 항상 상수로 선언해야 한다.

변숫값을 배열 크기로 사용할 수 없다. 

```go
package main

const Y int = 3 //상수

func main() {
	var x int = 5 //변수
	a := [x]int{1, 2, 3, 4, 5} // ERROR >> 변수를 배열크기로 사용할 수 없음

	b := [Y]int{1, 2, 3} // OK

	var c [10]int // OK
}
```

### 📌 배열 요소 읽고 쓰기

```go
package main

import "fmt"

func main() {
	nums := [...]int{10, 20, 30, 40, 50} //배열 크기 생략

	nums[2] = 300

	for i := 0; i < len(nums); i++ {
		fmt.Println(nums[i])
	}
}
```

### 📌 range 순회

for 반복문에서 range 키워드를 이용하면 배열의 index와 element를 동시에 순회할 수 있다.   

→ `for i, element := range arr { }`

```go
package main

import "fmt"

func main() {
	var t [5]float64 = [5]float64{24.0, 25.9, 27.8, 26.0, 30.0}

	for i, v := range t {
		fmt.Println(i, v)
	}
}
```

### → range 순회 시, 밑줄 _ 이용 (무효화 가능)

```go
for _, v := range t {
	fmt.Println(v)
}
```

→ 왜 이렇게 하는가?    

선언하고 사용하지 않는 변수가 있으면 **컴파일 에러**를 발생시키기 때문이다.    

따라서 range를 사용할 때 인덱스를 사용하지 않는다면 밑줄 _을 사용해서 반드시 값을 무효화 해주자.

## 12.3 배열은 연속된 메모리

컴퓨터가 배열을 인식하는 방법?   

→ 인덱스와 타입 크기를 사용해서 메모리 주소를 계산한다.    

→ `요소 위치` = `(배열 시작 주소)` + `(인덱스*타입 크기)`

### 배열 복사

대입 연산자 = 을 사용하면 배열 대 배열 복사가 가능하다.

```go
package main

import "fmt"

func main() {
	a := [5]int{1, 2, 3, 4, 5}
	b := [5]int{500, 200, 3300, 4500, 521}

	for i, v := range a {
		fmt.Printf("a[%d] = %d\n", i, v)
	}
	fmt.Println()
	for i, v := range b {
		fmt.Printf("b[%d] = %d\n", i, v)
	}

	b = a //배열 복사
	fmt.Println()
	for i, v := range b {
		fmt.Printf("b[%d] = %d\n", i, v)
	}

}
```

→ 결과

```bash
C:\Users\a\Desktop\goproject\chapter 12\ex12.5>.\ex12.5.go.exe 
a[0] = 1
a[1] = 2
a[2] = 3
a[3] = 4
a[4] = 5

b[0] = 500
b[1] = 200
b[2] = 3300
b[3] = 4500
b[4] = 521

b[0] = 1
b[1] = 2
b[2] = 3
b[3] = 4
b[4] = 5
```

### 주의

당연히! 배열을 복사할 때에는 배열 요소의 타입이 같은 배열끼리만 가능하다.    

float64 타입의 배열을 int 배열로 복사할 수는 없다.

### 배열 크기에 대하여

배열이 선언되면 컴퓨터는 배열의 모든 요소를 연속되게 저장할 수 있는 메모리 공간을 할당한다. [5]int에는 메모리 공간이 얼마나 필요할까?    

→ int 타입 크기는 8바이트이고, 요소가 5개이므로, 8*5 = **40바이트**의 공간이 필요하다.   

💡 따라서, **배열 크기 = 타입 크기 * 항목 개수**

## 12.4 다중 배열

- 2차원 배열
- 3차원 배열
- ...

`var b [2][5]int`   

→ [5]int 가 2개인 배열   

- b[0] 은 첫 번째 [5]int 배열이 된다.
- b[1][2]는 b 배열의 두 번째 [5]int 배열 내의 3번째 요소를 가리킨다.

즉, 몇 개가 중첩됐든, **[ 개수 ] 타입** 형태로 이해하면 된다.

### 다중 배열 초기화

```go
var a = [2][5]int {
	{1,2,3,4,5},
	{6,7,8,9,10},  //닫는 중괄호가 같은 줄이 아니면 쉼표 찍기!!!
}
```

### 다중 배열 원소에 접근하는 방법

```go
	for _, arr := range a {
		for _, v := range arr {
			fmt.Print(v, " ")  // v값 출력
		}
	}
```

# Chapter 12 연습문제

1. 6
2. float64가 8바이트이므로, 3*2*5*8 = 240 바이트이다.
3. 4   
    
    → ChangeArray() 함수의 인수로 a 값이 **복사**되기 때문에 arr와 a는 서로 다른 메모리 주소를 가진 다른 배열이다.    
    
    그러므로 arr[3]의 값을 바꿔도 a[3]의 값은 **바뀌지 않는다.**
